"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ArchiveItemRequest_1 = require("./Requests/ArchiveItemRequest");
var AutodiscoverErrorCode_1 = require("../Enumerations/AutodiscoverErrorCode");
var AutodiscoverLocalException_1 = require("../Exceptions/AutodiscoverLocalException");
var AutodiscoverService_1 = require("../Autodiscover/AutodiscoverService");
var AvailabilityOptions_1 = require("../Misc/Availability/AvailabilityOptions");
var CopyFolderRequest_1 = require("./Requests/CopyFolderRequest");
var CopyItemRequest_1 = require("./Requests/CopyItemRequest");
var CreateAttachmentRequest_1 = require("./Requests/CreateAttachmentRequest");
var CreateFolderRequest_1 = require("./Requests/CreateFolderRequest");
var CreateItemRequest_1 = require("./Requests/CreateItemRequest");
var CreateResponseObjectRequest_1 = require("./Requests/CreateResponseObjectRequest");
var DateTimePrecision_1 = require("../Enumerations/DateTimePrecision");
var DeleteAttachmentRequest_1 = require("./Requests/DeleteAttachmentRequest");
var DeleteFolderRequest_1 = require("./Requests/DeleteFolderRequest");
var DeleteItemRequest_1 = require("./Requests/DeleteItemRequest");
var EmailAddress_1 = require("../ComplexProperties/EmailAddress");
var EmptyFolderRequest_1 = require("./Requests/EmptyFolderRequest");
var EwsUtilities_1 = require("./EwsUtilities");
var ExchangeVersion_1 = require("../Enumerations/ExchangeVersion");
var ExpandGroupRequest_1 = require("./Requests/ExpandGroupRequest");
var FindFolderRequest_1 = require("./Requests/FindFolderRequest");
var FindItemRequest_1 = require("./Requests/FindItemRequest");
var FolderId_1 = require("../ComplexProperties/FolderId");
var FolderView_1 = require("../Search/FolderView");
var GetAttachmentRequest_1 = require("./Requests/GetAttachmentRequest");
var GetFolderRequestForLoad_1 = require("./Requests/GetFolderRequestForLoad");
var GetFolderRequest_1 = require("./Requests/GetFolderRequest");
var GetItemRequestForLoad_1 = require("./Requests/GetItemRequestForLoad");
var GetItemRequest_1 = require("./Requests/GetItemRequest");
var GetPasswordExpirationDateRequest_1 = require("./Requests/GetPasswordExpirationDateRequest");
var GetUserAvailabilityRequest_1 = require("./Requests/GetUserAvailabilityRequest");
var GetUserOofSettingsRequest_1 = require("./Requests/GetUserOofSettingsRequest");
var Grouping_1 = require("../Search/Grouping");
var ItemId_1 = require("../ComplexProperties/ItemId");
var MarkAllItemsAsReadRequest_1 = require("./Requests/MarkAllItemsAsReadRequest");
var MarkAsJunkRequest_1 = require("./Requests/MarkAsJunkRequest");
var MoveFolderRequest_1 = require("./Requests/MoveFolderRequest");
var MoveItemRequest_1 = require("./Requests/MoveItemRequest");
var PropertySet_1 = require("./PropertySet");
var RenderingMode_1 = require("../Enumerations/RenderingMode");
var ResolveNamesRequest_1 = require("./Requests/ResolveNamesRequest");
var SearchFilter_1 = require("../Search/Filters/SearchFilter");
var SendItemRequest_1 = require("./Requests/SendItemRequest");
var ServiceErrorHandling_1 = require("../Enumerations/ServiceErrorHandling");
var ServiceLocalException_1 = require("../Exceptions/ServiceLocalException");
var ServiceRemoteException_1 = require("../Exceptions/ServiceRemoteException");
var ServiceValidationException_1 = require("../Exceptions/ServiceValidationException");
var SetUserOofSettingsRequest_1 = require("./Requests/SetUserOofSettingsRequest");
var ExtensionMethods_1 = require("../ExtensionMethods");
var Strings_1 = require("../Strings");
var TraceFlags_1 = require("../Enumerations/TraceFlags");
var UnifiedMessaging_1 = require("../UnifiedMessaging/UnifiedMessaging");
var UpdateFolderRequest_1 = require("./Requests/UpdateFolderRequest");
var UpdateItemRequest_1 = require("./Requests/UpdateItemRequest");
var Uri_1 = require("../Uri");
var UserSettingName_1 = require("../Enumerations/UserSettingName");
var ViewBase_1 = require("../Search/ViewBase");
var ExchangeServiceBase_1 = require("./ExchangeServiceBase");
/**
 * Represents a binding to the **Exchange Web Services**.
 *
 */
var ExchangeService = (function (_super) {
    __extends(ExchangeService, _super);
    function ExchangeService() {
        _super.apply(this, arguments);
        /* #endregion Constants */
        /* #region Fields */
        this.url = null;
        //private preferredCulture: any = null;// System.Globalization.CultureInfo;
        //private dateTimePrecision: DateTimePrecision = DateTimePrecision.Default;
        //private impersonatedUserId: ImpersonatedUserId = null;
        //private privilegedUserId: PrivilegedUserId = null;
        //private managementRoles: ManagementRoles = null;
        //private fileAttachmentContentHandler: IFileAttachmentContentHandler = null;
        this.unifiedMessaging = null;
        //private enableScpLookup: boolean = false; //false for javascript, AD Lookup not implemented 
        this.renderingMode = RenderingMode_1.RenderingMode.Xml;
        //private traceEnablePrettyPrinting: boolean = true;
        this.targetServerVersion = null;
        this.ImpersonatedUserId = null;
        this.PrivilegedUserId = null;
        this.ManagementRoles = null;
        this.PreferredCulture = null; //System.Globalization.CultureInfo;
        this.DateTimePrecision = DateTimePrecision_1.DateTimePrecision.Default;
        this.FileAttachmentContentHandler = null;
        this.Exchange2007CompatibilityMode = false;
        this.TraceEnablePrettyPrinting = true;
    }
    Object.defineProperty(ExchangeService.prototype, "TimeZone", {
        get: function () {
            return this.timeZone;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ExchangeService.prototype, "UnifiedMessaging", {
        get: function () {
            if (this.unifiedMessaging === null) {
                this.unifiedMessaging = new UnifiedMessaging_1.UnifiedMessaging(this);
            }
            return this.unifiedMessaging;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ExchangeService.prototype, "EnableScpLookup", {
        get: function () { return false; } //false for javascript, AD Lookup not implemented
        ,
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ExchangeService.prototype, "RenderingMethod", {
        get: function () { return this.renderingMode; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ExchangeService.prototype, "TargetServerVersion", {
        get: function () {
            return this.targetServerVersion;
        },
        set: function (value) {
            ExchangeService.ValidateTargetVersion(value);
            this.targetServerVersion = value;
        },
        enumerable: true,
        configurable: true
    });
    /* #region Properties */
    /* #region Response object operations */
    /**
     * @internal Create response object.
     *
     * @param   {ServiceObject}          responseObject       The response object.
     * @param   {FolderId}               parentFolderId       The parent folder id.
     * @param   {MessageDisposition}     messageDisposition   The message disposition.
     * @return  {IPromise<Item[]>}       The list of items created or modified as a result of the "creation" of the response object :Promise.
     */
    ExchangeService.prototype.InternalCreateResponseObject = function (responseObject, parentFolderId, messageDisposition) {
        var request = new CreateResponseObjectRequest_1.CreateResponseObjectRequest(this, ServiceErrorHandling_1.ServiceErrorHandling.ThrowOnError);
        request.ParentFolderId = parentFolderId;
        request.Items = [responseObject];
        request.MessageDisposition = messageDisposition;
        return request.Execute().then(function (responses) {
            return responses.__thisIndexer(0).Items;
        });
    };
    ExchangeService.prototype.BindToFolder = function (folderId, propertySet, /** pass Folder or subclass itself, not an instance */ folderType) {
        if (folderType === void 0) { folderType = null; }
        EwsUtilities_1.EwsUtilities.ValidateParam(folderId, "folderId");
        EwsUtilities_1.EwsUtilities.ValidateParam(propertySet, "propertySet");
        var request = new GetFolderRequest_1.GetFolderRequest(this, ServiceErrorHandling_1.ServiceErrorHandling.ThrowOnError);
        request.FolderIds.Add(folderId);
        request.PropertySet = propertySet;
        return request.Execute().then(function (responses) {
            var result = responses.__thisIndexer(0).Folder;
            if (folderType != null && !(result instanceof folderType)) {
                throw new ServiceLocalException_1.ServiceLocalException(ExtensionMethods_1.StringHelper.Format(Strings_1.Strings.FolderTypeNotCompatible, "Type detection not implemented - ExchangeService.ts - BindToFolder<TFolder>", "Type detection not implemented"));
            }
            return result;
        });
    };
    /**
     * @internal Copies a folder. Calling this method results in a call to EWS.
     *
     * @param   {FolderId}           folderId              The folder id.
     * @param   {FolderId}           destinationFolderId   The destination folder id.
     * @return  {IPromise<Folder>}   Copy of folder :Promise.
     */
    ExchangeService.prototype.CopyFolder = function (folderId, destinationFolderId) {
        var request = new CopyFolderRequest_1.CopyFolderRequest(this, ServiceErrorHandling_1.ServiceErrorHandling.ThrowOnError);
        request.DestinationFolderId = destinationFolderId;
        request.FolderIds.Add(folderId);
        return request.Execute().then(function (responses) {
            return responses.__thisIndexer(0).Folder;
        });
    };
    /**
     * @internal Creates a folder. Calling this method results in a call to EWS.
     *
     * @param   {FolderId}   folder           The folder.
     * @param   {FolderId}   parentFolderId   The parent folder id.
     */
    ExchangeService.prototype.CreateFolder = function (folder, parentFolderId) {
        var request = new CreateFolderRequest_1.CreateFolderRequest(this, ServiceErrorHandling_1.ServiceErrorHandling.ThrowOnError);
        request.Folders = [folder];
        request.ParentFolderId = parentFolderId;
        return request.Execute();
    };
    /**
     * @internal Deletes a folder. Calling this method results in a call to EWS.
     *
     * @param   {FolderId}      folderId     The folder id.
     * @param   {DeleteMode}    deleteMode   The delete mode.
     */
    ExchangeService.prototype.DeleteFolder = function (folderId, deleteMode) {
        EwsUtilities_1.EwsUtilities.ValidateParam(folderId, "folderId");
        var request = new DeleteFolderRequest_1.DeleteFolderRequest(this, ServiceErrorHandling_1.ServiceErrorHandling.ThrowOnError);
        request.FolderIds.Add(folderId);
        request.DeleteMode = deleteMode;
        return request.Execute();
    };
    /**
     * @internal Empties a folder. Calling this method results in a call to EWS.
     *
     * @param   {FolderId}      folderId           The folder id.
     * @param   {DeleteMode}    deleteMode         The delete mode.
     * @param   {boolean}       deleteSubFolders   if set to true empty folder should also delete sub folders.
     */
    ExchangeService.prototype.EmptyFolder = function (folderId, deleteMode, deleteSubFolders) {
        EwsUtilities_1.EwsUtilities.ValidateParam(folderId, "folderId");
        var request = new EmptyFolderRequest_1.EmptyFolderRequest(this, ServiceErrorHandling_1.ServiceErrorHandling.ThrowOnError);
        request.FolderIds.Add(folderId);
        request.DeleteMode = deleteMode;
        request.DeleteSubFolders = deleteSubFolders;
        return request.Execute();
    };
    ExchangeService.prototype.FindFolders = function (parentFolderIdOrName, viewOrSearchFilter, folderView) {
        //todo: better argument check with ewsutilities
        //EwsUtilities.ValidateParam(parentFolderId, "parentFolderId");
        //EwsUtilities.ValidateParam(view, "view");
        //EwsUtilities.ValidateParamAllowNull(searchFilter, "searchFilter");
        var argsLength = arguments.length;
        if (argsLength < 2 && argsLength > 3) {
            throw new Error("ExchangeService.ts - FindFolders - invalid number of arguments, check documentation and try again.");
        }
        //position 1 - parentFolderIdOrName
        var parentFolderIds = [];
        if (typeof parentFolderIdOrName === 'number') {
            parentFolderIds.push(new FolderId_1.FolderId(parentFolderIdOrName));
        }
        else if (parentFolderIdOrName instanceof FolderId_1.FolderId) {
            parentFolderIds.push(parentFolderIdOrName);
        }
        else {
            throw new Error("ExchangeService.ts - FindFolders - incorrect use of parameters, 1st argument must be Folder ID or WellKnownFolderName");
        }
        var searchFilter = null;
        var view = null;
        //position 2 - viewOrSearchFilter
        if (viewOrSearchFilter instanceof SearchFilter_1.SearchFilter) {
            if (!(folderView instanceof FolderView_1.FolderView)) {
                throw new Error("ExchangeService.ts - FindFolders with " + argsLength + " parameters - incorrect uses of parameter at 3nd position, it must be FolderView when using SearchFilter at 2nd place");
            }
            searchFilter = viewOrSearchFilter;
        }
        else if (viewOrSearchFilter instanceof FolderView_1.FolderView) {
            view = viewOrSearchFilter;
        }
        else {
            throw new Error("ExchangeService.ts - FindFolders - incorrect uses of parameters at 2nd position, must be FolderView or SearchFilter");
        }
        //position 3 - folderView
        if (argsLength == 3) {
            view = folderView;
        }
        return this.InternalFindFolders(parentFolderIds, searchFilter, /* searchFilter */ view, ServiceErrorHandling_1.ServiceErrorHandling.ThrowOnError).then(function (responses) {
            return responses.__thisIndexer(0).Results;
        });
    };
    /**
     * Finds folders.
     *
     * @param   {FolderId[]}             parentFolderIds     The parent folder ids.
     * @param   {SearchFilter}           searchFilter        The search filter. Available search filter classes include SearchFilter.IsEqualTo, SearchFilter.ContainsSubstring and SearchFilter.SearchFilterCollection
     * @param   {FolderView}             view                The view controlling the number of folders returned.
     * @param   {ServiceErrorHandling}   errorHandlingMode   Indicates the type of error handling should be done.
     * @return  {IPromise<ServiceResponseCollection<FindFolderResponse>>}    Collection of service responses :Promise.
     */
    ExchangeService.prototype.InternalFindFolders = function (parentFolderIds, searchFilter, view, errorHandlingMode) {
        var request = new FindFolderRequest_1.FindFolderRequest(this, errorHandlingMode);
        request.ParentFolderIds.AddRange(parentFolderIds);
        request.SearchFilter = searchFilter;
        request.View = view;
        return request.Execute();
    };
    /**
     * @internal Load specified properties for a folder.
     *
     * @param   {Folder}         folder        The folder.
     * @param   {PropertySet}    propertySet   The property set.
     */
    ExchangeService.prototype.LoadPropertiesForFolder = function (folder, propertySet) {
        EwsUtilities_1.EwsUtilities.ValidateParam(folder, "folder");
        EwsUtilities_1.EwsUtilities.ValidateParam(propertySet, "propertySet");
        var request = new GetFolderRequestForLoad_1.GetFolderRequestForLoad(this, ServiceErrorHandling_1.ServiceErrorHandling.ThrowOnError);
        request.FolderIds.Add(folder);
        request.PropertySet = propertySet;
        return request.Execute();
    };
    /**
     * @internal Marks all items in folder as read/unread. Calling this method results in a call to EWS.
     *
     * @param   {FolderId}      folderId               The folder id.
     * @param   {boolean}       readFlag               If true, items marked as read, otherwise unread.
     * @param   {boolean}       suppressReadReceipts   If true, suppress read receipts for items.
     */
    ExchangeService.prototype.MarkAllItemsAsRead = function (folderId, readFlag, suppressReadReceipts) {
        EwsUtilities_1.EwsUtilities.ValidateParam(folderId, "folderId");
        EwsUtilities_1.EwsUtilities.ValidateMethodVersion(this, ExchangeVersion_1.ExchangeVersion.Exchange2013, "MarkAllItemsAsRead");
        var request = new MarkAllItemsAsReadRequest_1.MarkAllItemsAsReadRequest(this, ServiceErrorHandling_1.ServiceErrorHandling.ThrowOnError);
        request.FolderIds.Add(folderId);
        request.ReadFlag = readFlag;
        request.SuppressReadReceipts = suppressReadReceipts;
        return request.Execute();
    };
    /**
     * @internal Move a folder.
     *
     * @param   {FolderId}           folderId              The folder id.
     * @param   {FolderId}           destinationFolderId   The destination folder id.
     * @return  {IPromise<Folder>}   Moved folder :Promise.
     */
    ExchangeService.prototype.MoveFolder = function (folderId, destinationFolderId) {
        var request = new MoveFolderRequest_1.MoveFolderRequest(this, ServiceErrorHandling_1.ServiceErrorHandling.ThrowOnError);
        request.DestinationFolderId = destinationFolderId;
        request.FolderIds.Add(folderId);
        return request.Execute().then(function (responses) {
            return responses.__thisIndexer(0).Folder;
        });
    };
    /**
     * @internal Updates a folder.
     *
     * @param   {Folder}   folder   The folder.
     */
    ExchangeService.prototype.UpdateFolder = function (folder) {
        var request = new UpdateFolderRequest_1.UpdateFolderRequest(this, ServiceErrorHandling_1.ServiceErrorHandling.ThrowOnError);
        request.Folders.push(folder);
        return request.Execute().then(function (value) {
            return null;
        });
    };
    /* #endregion Folder operations */
    /* #region Item operations */
    /**
     * Archives multiple items in a single call to EWS.
     *
     * @param   {ItemId[]}   itemIds          The Ids of the items to move.
     * @param   {FolderId}   sourceFolderId   The Id of the folder in primary corresponding to which items are being archived to.
     * @return  {IPromise<ServiceResponseCollection<ArchiveItemResponse>>}                    A ServiceResponseCollection providing copy results for each of the specified item Ids :Promise.
     */
    ExchangeService.prototype.ArchiveItems = function (itemIds, sourceFolderId) {
        var request = new ArchiveItemRequest_1.ArchiveItemRequest(this, ServiceErrorHandling_1.ServiceErrorHandling.ReturnErrors);
        request.Ids.AddRange(itemIds);
        request.SourceFolderId = sourceFolderId;
        return request.Execute();
    };
    /* //ref: new method, //todo: implement other newer code from ews managed api repo  */
    /**
     * Binds to multiple items in a single call to EWS.
     *
     * @param   {ItemId[]}      itemIds         The Ids of the items to bind to.
     * @param   {PropertySet}   propertySet     The set of properties to load.
     * @param   {string}        anchorMailbox   The SmtpAddress of mailbox that hosts all items we need to bind to
     * @return  {IPromise<ServiceResponseCollection<GetItemResponse>>}                   A ServiceResponseCollection providing results for each of the specified item Ids :Promise.
     */
    ExchangeService.prototype.BindToGroupItems = function (itemIds, propertySet, anchorMailbox) {
        EwsUtilities_1.EwsUtilities.ValidateParamCollection(itemIds, "itemIds");
        EwsUtilities_1.EwsUtilities.ValidateParam(propertySet, "propertySet");
        EwsUtilities_1.EwsUtilities.ValidateParam(propertySet, "anchorMailbox");
        return this.InternalBindToItems(itemIds, propertySet, anchorMailbox, ServiceErrorHandling_1.ServiceErrorHandling.ReturnErrors);
    };
    ExchangeService.prototype.BindToItem = function (itemId, propertySet, /** pass Item or subclass itself, not an instance */ itemType) {
        if (itemType === void 0) { itemType = null; }
        EwsUtilities_1.EwsUtilities.ValidateParam(itemId, "itemId");
        EwsUtilities_1.EwsUtilities.ValidateParam(propertySet, "propertySet");
        return this.InternalBindToItems([itemId], propertySet, null, /* anchorMailbox */ ServiceErrorHandling_1.ServiceErrorHandling.ThrowOnError).then(function (response) {
            var result = response.__thisIndexer(0).Item;
            if (itemType != null && !(result instanceof itemType)) {
                throw new ServiceLocalException_1.ServiceLocalException(ExtensionMethods_1.StringHelper.Format(Strings_1.Strings.ItemTypeNotCompatible, "Type detection not implemented - ExchangeService.ts - BindToItem<TItem>", "Type detection not implemented"));
            }
            return result;
        });
    };
    /**
     * Binds to multiple items in a single call to EWS.
     *
     * @param   {ItemId[]}      itemIds       The Ids of the items to bind to.
     * @param   {PropertySet}   propertySet   The set of properties to load.
     * @return  {IPromise<ServiceResponseCollection<GetItemResponse>>}                 A ServiceResponseCollection providing results for each of the specified item Ids :Promise.
     */
    ExchangeService.prototype.BindToItems = function (itemIds, propertySet) {
        EwsUtilities_1.EwsUtilities.ValidateParamCollection(itemIds, "itemIds");
        EwsUtilities_1.EwsUtilities.ValidateParam(propertySet, "propertySet");
        return this.InternalBindToItems(itemIds, propertySet, null, /* anchorMailbox */ ServiceErrorHandling_1.ServiceErrorHandling.ReturnErrors);
    };
    /**
     * @internal Copies an item. Calling this method results in a call to EWS.
     *
     * @param   {ItemId}        itemId                The Id of the item to copy.
     * @param   {FolderId}      destinationFolderId   The Id of the folder to copy the item to.
     * @return  {IPromise<Item>}    The copy of the item :Promise.
     */
    ExchangeService.prototype.CopyItem = function (itemId, destinationFolderId) {
        return this.InternalCopyItems([itemId], destinationFolderId, null, ServiceErrorHandling_1.ServiceErrorHandling.ThrowOnError).then(function (response) {
            return response.__thisIndexer(0).Item;
        });
    };
    ExchangeService.prototype.CopyItems = function (itemIds, destinationFolderId, returnNewItemIds) {
        if (returnNewItemIds === void 0) { returnNewItemIds = null; }
        EwsUtilities_1.EwsUtilities.ValidateMethodVersion(this, ExchangeVersion_1.ExchangeVersion.Exchange2010_SP1, "CopyItems");
        return this.InternalCopyItems(itemIds, destinationFolderId, returnNewItemIds, ServiceErrorHandling_1.ServiceErrorHandling.ReturnErrors);
    };
    /**
     * @internal Creates an item. Calling this method results in a call to EWS.
     *
     * @param   {Item}                  item                  The item to create.
     * @param   {FolderId}              parentFolderId        The Id of the folder in which to place the newly created item. If null, the item is created in its default folders.
     * @param   {MessageDisposition}    messageDisposition    Indicates the disposition mode for items of type EmailMessage. Required if item is an EmailMessage instance.
     * @param   {SendInvitationsMode}   sendInvitationsMode   Indicates if and how invitations should be sent for item of type Appointment. Required if item is an Appointment instance.
     */
    ExchangeService.prototype.CreateItem = function (item, parentFolderId, messageDisposition, sendInvitationsMode) {
        return this.InternalCreateItems([item], parentFolderId, messageDisposition, sendInvitationsMode, ServiceErrorHandling_1.ServiceErrorHandling.ThrowOnError);
    };
    /**
     * Creates multiple items in a single EWS call. Supported item classes are EmailMessage, Appointment, Contact, PostItem, Task and Item. CreateItems does not support items that have unsaved attachments.
     *
     * @param   {Item[]}                items                 The items to create.
     * @param   {FolderId}              parentFolderId        The Id of the folder in which to place the newly created items. If null, items are created in their default folders.
     * @param   {MessageDisposition}    messageDisposition    Indicates the disposition mode for items of type EmailMessage. Required if items contains at least one EmailMessage instance.
     * @param   {SendInvitationsMode}   sendInvitationsMode   Indicates if and how invitations should be sent for items of type Appointment. Required if items contains at least one Appointment instance.
     * @return  {IPromise<ServiceResponseCollection<ServiceResponse>>}                         A ServiceResponseCollection providing creation results for each of the specified items :Promise.
     */
    ExchangeService.prototype.CreateItems = function (items, parentFolderId, messageDisposition, sendInvitationsMode) {
        // All items have to be new.
        if (!items.every(function (item) { return item.IsNew; })) {
            throw new ServiceValidationException_1.ServiceValidationException(Strings_1.Strings.CreateItemsDoesNotHandleExistingItems);
        }
        // Make sure that all items do *not* have unprocessed attachments.
        if (!items.every(function (item) { return !item.HasUnprocessedAttachmentChanges(); })) {
            throw new ServiceValidationException_1.ServiceValidationException(Strings_1.Strings.CreateItemsDoesNotAllowAttachments);
        }
        return this.InternalCreateItems(items, parentFolderId, messageDisposition, sendInvitationsMode, ServiceErrorHandling_1.ServiceErrorHandling.ReturnErrors);
    };
    ExchangeService.prototype.DeleteItem = function (itemId, deleteMode, sendCancellationsMode, affectedTaskOccurrences, suppressReadReceipts) {
        if (suppressReadReceipts === void 0) { suppressReadReceipts = false; }
        EwsUtilities_1.EwsUtilities.ValidateParam(itemId, "itemId");
        return this.InternalDeleteItems([itemId], deleteMode, sendCancellationsMode, affectedTaskOccurrences, ServiceErrorHandling_1.ServiceErrorHandling.ThrowOnError, suppressReadReceipts);
    };
    ExchangeService.prototype.DeleteItems = function (itemIds, deleteMode, sendCancellationsMode, affectedTaskOccurrences, suppressReadReceipt) {
        if (suppressReadReceipt === void 0) { suppressReadReceipt = false; }
        EwsUtilities_1.EwsUtilities.ValidateParamCollection(itemIds, "itemIds");
        return this.InternalDeleteItems(itemIds, deleteMode, sendCancellationsMode, affectedTaskOccurrences, ServiceErrorHandling_1.ServiceErrorHandling.ReturnErrors, suppressReadReceipt);
    };
    ExchangeService.prototype.FindAppointments = function (parentFolderIdOrName, calendarView) {
        var parentFolderId = parentFolderIdOrName;
        if (typeof parentFolderIdOrName === 'number') {
            parentFolderId = new FolderId_1.FolderId(parentFolderIdOrName);
        }
        return this.FindItems([parentFolderId], null, /* searchFilter */ null, /* queryString */ calendarView, null, /* groupBy */ ServiceErrorHandling_1.ServiceErrorHandling.ThrowOnError).then(function (response) {
            return response.__thisIndexer(0).Results;
        });
    };
    //skipped: not needed, no calls coming in to this internal function in ews managed api, future use possible until them keep it muted   - 
    //FindItems<TItem extends Item>(parentFolderId: FolderId, searchFilter: SearchFilter, view: ViewBase, groupBy: Grouping): IPromise<ServiceResponseCollection<FindItemResponse<TItem>>>;
    ExchangeService.prototype.FindItems = function (nameIdOrIds, viewQueryStringOrSearchFilter, groupByViewRHTOrQueryString, groupByOrView, groupBy, errorHandlingMode) {
        //todo: better argument check with ewsutilities
        if (errorHandlingMode === void 0) { errorHandlingMode = ServiceErrorHandling_1.ServiceErrorHandling.ThrowOnError; }
        //EwsUtilities.ValidateParamAllowNull(searchFilter, "searchFilter");
        //EwsUtilities.ValidateParam(groupBy, "groupBy");
        //EwsUtilities.ValidateParamAllowNull(queryString, "queryString");
        //EwsUtilities.ValidateParamCollection(parentFolderIds, "parentFolderIds");
        //EwsUtilities.ValidateParam(view, "view");
        //EwsUtilities.ValidateParam(groupBy, "groupBy");
        //EwsUtilities.ValidateParamAllowNull(queryString, "queryString");
        //EwsUtilities.ValidateParamAllowNull(returnHighlightTerms, "returnHighlightTerms");
        //EwsUtilities.ValidateMethodVersion(this, ExchangeVersion.Exchange2013, "FindItems");
        var argsLength = arguments.length;
        if (argsLength < 2 && argsLength > 6) {
            throw new Error("ExchangeService.ts - FindItems - invalid number of arguments, check documentation and try again.");
        }
        //position 1 - nameIdOrIds
        var parentIds = [];
        if (typeof nameIdOrIds === 'number') {
            parentIds.push(new FolderId_1.FolderId(nameIdOrIds));
        }
        else if (nameIdOrIds instanceof FolderId_1.FolderId) {
            parentIds.push(nameIdOrIds);
        }
        else if (Array.isArray(nameIdOrIds)) {
            parentIds = nameIdOrIds;
        }
        var queryString = null;
        var searchFilter = null;
        var view = null;
        //position 2 - viewQueryStringOrSearchFilter
        if (argsLength >= 2)
            if (typeof viewQueryStringOrSearchFilter === 'string') {
                queryString = viewQueryStringOrSearchFilter;
            }
            else if (viewQueryStringOrSearchFilter instanceof SearchFilter_1.SearchFilter) {
                searchFilter = viewQueryStringOrSearchFilter;
            }
            else if (viewQueryStringOrSearchFilter instanceof ViewBase_1.ViewBase) {
                view = viewQueryStringOrSearchFilter;
            }
            else if (viewQueryStringOrSearchFilter) {
                throw new Error("ExchangeService.ts - FindItems - incorrect uses of parameters at 2nd position, must be string, ViewBase or SearchFilter");
            }
        var groupResultBy = null;
        var returnHighlightTerms = false;
        var isGroupped = false; // to resturn GroupedFindItemsResults<Item>
        //position 3 - groupByViewRHTOrQueryString
        if (argsLength >= 3) {
            if (groupByViewRHTOrQueryString instanceof Grouping_1.Grouping) {
                if (!(viewQueryStringOrSearchFilter instanceof ViewBase_1.ViewBase)) {
                    throw new Error("ExchangeService.ts - FindItems with " + argsLength + " parameters - incorrect uses of parameter at 3nd position, it must be ViewBase when using Grouping at 4th place");
                }
                groupResultBy = groupByViewRHTOrQueryString;
                isGroupped = true;
            }
            else if (groupByViewRHTOrQueryString instanceof ViewBase_1.ViewBase) {
                view = groupByViewRHTOrQueryString;
            }
            else if (typeof groupByViewRHTOrQueryString === 'string') {
                queryString = groupByViewRHTOrQueryString;
            }
            else if (typeof groupByViewRHTOrQueryString === 'boolean') {
                returnHighlightTerms = groupByViewRHTOrQueryString;
                EwsUtilities_1.EwsUtilities.ValidateMethodVersion(this, ExchangeVersion_1.ExchangeVersion.Exchange2013, "FindItems");
            }
            else if (groupByViewRHTOrQueryString) {
                throw new Error("ExchangeService.ts - FindItems with " + argsLength + " parameters - incorrect uses of parameter at 3rd position, must be string, boolean, ViewBase or Grouping");
            }
        }
        //position 4 - groupByOrView
        if (argsLength >= 4) {
            if (groupByOrView instanceof Grouping_1.Grouping) {
                if (!(groupByViewRHTOrQueryString instanceof ViewBase_1.ViewBase)) {
                    throw new Error("ExchangeService.ts - FindItems with " + argsLength + " parameters - incorrect uses of parameter at 3rd position, it must be ViewBase when using Grouping at 3rd place");
                }
                groupResultBy = groupByOrView;
                isGroupped = true;
            }
            else if (groupByOrView instanceof ViewBase_1.ViewBase) {
                view = groupByOrView;
            }
            else if (groupByOrView) {
                throw new Error("ExchangeService.ts - FindItems with " + argsLength + " parameters - incorrect uses of parameter at 4th  position, must be  ViewBase or Grouping");
            }
        }
        //position 5 - groupBy
        if (argsLength >= 5) {
            if (groupByOrView && !(groupByOrView instanceof ViewBase_1.ViewBase)) {
                throw new Error("ExchangeService.ts - FindItems with " + argsLength + " parameters - incorrect uses of parameter at 4th position, it must be ViewBase when using Grouping at 5th place");
            }
            groupResultBy = groupBy;
            isGroupped = true;
        }
        var isRaw = false; // to return ServiceResponseCollection<FindItemResponse<TItem>>
        //position 6 - errorHandlingMode
        if (argsLength === 6) {
            isRaw = true;
        }
        var request = new FindItemRequest_1.FindItemRequest(this, errorHandlingMode | ServiceErrorHandling_1.ServiceErrorHandling.ThrowOnError);
        request.ParentFolderIds.AddRange(parentIds);
        request.SearchFilter = searchFilter;
        request.QueryString = queryString;
        request.View = view;
        request.GroupBy = groupResultBy;
        return request.Execute().then(function (responses) {
            if (isRaw) {
                return responses;
            }
            if (isGroupped) {
                return responses.__thisIndexer(0).GroupedFindResults;
            }
            return responses.__thisIndexer(0).Results;
        });
    };
    /**
     * Binds to multiple items in a single call to EWS.
     *
     * @param   {ItemId[]}              itemIds         The Ids of the items to bind to.
     * @param   {PropertySet}           propertySet     The set of properties to load.
     * @param   {string}                anchorMailbox   The SmtpAddress of mailbox that hosts all items we need to bind to
     * @param   {ServiceErrorHandling}  errorHandling   Type of error handling to perform.
     * @return  {IPromise<ServiceResponseCollection<GetItemResponse>>}      A ServiceResponseCollection providing results for each of the specified item Ids :Promise.
     */
    ExchangeService.prototype.InternalBindToItems = function (itemIds, propertySet, anchorMailbox, errorHandling) {
        var request = new GetItemRequest_1.GetItemRequest(this, errorHandling);
        request.ItemIds.AddRange(itemIds);
        request.PropertySet = propertySet;
        request.AnchorMailbox = anchorMailbox;
        return request.Execute();
    };
    /**
     * Copies multiple items in a single call to EWS.
     *
     * @param   {ItemId[]}              itemIds                 The Ids of the items to bind to.
     * @param   {FolderId}              destinationFolderId     The Id of the folder to copy the items to.
     * @param   {boolean}               returnNewItemIds        Flag indicating whether service should return new ItemIds or not.
     * @param   {ServiceErrorHandling}  errorHandling           What type of error handling should be performed.
     * @return  {IPromise<ServiceResponseCollection<MoveCopyItemResponse>>}     A ServiceResponseCollection providing copy results for each of the specified item Ids :Promise.
     */
    ExchangeService.prototype.InternalCopyItems = function (itemIds, destinationFolderId, returnNewItemIds, errorHandling) {
        var request = new CopyItemRequest_1.CopyItemRequest(this, errorHandling);
        request.ItemIds.AddRange(itemIds);
        request.DestinationFolderId = destinationFolderId;
        request.ReturnNewItemIds = returnNewItemIds;
        return request.Execute();
    };
    /**
     * Creates multiple items in a single EWS call. Supported item classes are EmailMessage, Appointment, Contact, PostItem, Task and Item. CreateItems does not support items that have unsaved attachments.
     *
     * @param   {Item[]}                items                 The items to create.
     * @param   {FolderId}              parentFolderId        The Id of the folder in which to place the newly created items. If null, items are created in their default folders.
     * @param   {MessageDisposition}    messageDisposition    Indicates the disposition mode for items of type EmailMessage. Required if items contains at least one EmailMessage instance.
     * @param   {SendInvitationsMode}   sendInvitationsMode   Indicates if and how invitations should be sent for items of type Appointment. Required if items contains at least one Appointment instance.
     * @param   {ServiceErrorHandling}  errorHandling         What type of error handling should be performed.
     * @return  {IPromise<ServiceResponseCollection<ServiceResponse>>}      A ServiceResponseCollection providing creation results for each of the specified items :Promise.
     */
    ExchangeService.prototype.InternalCreateItems = function (items, parentFolderId, messageDisposition, sendInvitationsMode, errorHandling) {
        var request = new CreateItemRequest_1.CreateItemRequest(this, errorHandling);
        request.ParentFolderId = parentFolderId;
        request.Items = items;
        request.MessageDisposition = messageDisposition;
        request.SendInvitationsMode = sendInvitationsMode;
        return request.Execute();
    };
    /**
     * Deletes multiple items in a single call to EWS.
     *
     * @param   {ItemId[]}                  itemIds                   The Ids of the items to delete.
     * @param   {DeleteMode}                deleteMode                The deletion mode.
     * @param   {SendCancellationsMode}     sendCancellationsMode     Indicates whether cancellation messages should be sent. Required if any of the item Ids represents an Appointment.
     * @param   {AffectedTaskOccurrence}    affectedTaskOccurrences   Indicates which instance of a recurring task should be deleted. Required if any of the item Ids represents a Task.
     * @param   {ServiceErrorHandling}      errorHandling             Type of error handling to perform.
     * @param   {boolean}                   suppressReadReceipts      Whether to suppress read receipts
     * @return  {IPromise<ServiceResponseCollection<ServiceResponse>>}      A ServiceResponseCollection providing deletion results for each of the specified item Ids :Promise.
     */
    ExchangeService.prototype.InternalDeleteItems = function (itemIds, deleteMode, sendCancellationsMode, affectedTaskOccurrences, errorHandling, suppressReadReceipts) {
        var request = new DeleteItemRequest_1.DeleteItemRequest(this, errorHandling);
        request.ItemIds.AddRange(itemIds);
        request.DeleteMode = deleteMode;
        request.SendCancellationsMode = sendCancellationsMode;
        request.AffectedTaskOccurrences = affectedTaskOccurrences;
        request.SuppressReadReceipts = suppressReadReceipts;
        return request.Execute();
    };
    /**
     * @internal Loads the properties of multiple items in a single call to EWS.
     *
     * @param   {Item[]}                items           The items to load the properties of.
     * @param   {PropertySet}           propertySet     The set of properties to load.
     * @param   {ServiceErrorHandling}  errorHandling   Indicates the type of error handling should be done.
     * @return  {IPromise<ServiceResponseCollection<ServiceResponse>>}      A ServiceResponseCollection providing results for each of the specified items :Promise.
     */
    ExchangeService.prototype.InternalLoadPropertiesForItems = function (items, propertySet, errorHandling) {
        var request = new GetItemRequestForLoad_1.GetItemRequestForLoad(this, errorHandling);
        request.ItemIds.AddRange(items);
        request.PropertySet = propertySet;
        return request.Execute();
    };
    /**
     * Moves multiple items in a single call to EWS.
     *
     * @param   {ItemId[]}              itemIds               The Ids of the items to move.
     * @param   {FolderId}              destinationFolderId   The Id of the folder to move the items to.
     * @param   {boolean}               returnNewItemIds      Flag indicating whether service should return new ItemIds or not.
     * @param   {ServiceErrorHandling}  errorHandling         What type of error handling should be performed.
     * @return  {IPromise<ServiceResponseCollection<MoveCopyItemResponse>>}     A ServiceResponseCollection providing copy results for each of the specified item Ids :Promise.
     */
    ExchangeService.prototype.InternalMoveItems = function (itemIds, destinationFolderId, returnNewItemIds, errorHandling) {
        var request = new MoveItemRequest_1.MoveItemRequest(this, errorHandling);
        request.ItemIds.AddRange(itemIds);
        request.DestinationFolderId = destinationFolderId;
        request.ReturnNewItemIds = returnNewItemIds;
        return request.Execute();
    };
    /**
     * Updates multiple items in a single EWS call. UpdateItems does not support items that have unsaved attachments.
     *
     * @param   {Item[]}                                items                                The items to update.
     * @param   {FolderId}                              savedItemsDestinationFolderId        The folder in which to save sent messages, meeting invitations or cancellations. If null, the messages, meeting invitation or cancellations are saved in the Sent Items folder.
     * @param   {ConflictResolutionMode}                conflictResolution                   The conflict resolution mode.
     * @param   {MessageDisposition}                    messageDisposition                   Indicates the disposition mode for items of type EmailMessage. Required if items contains at least one EmailMessage instance.
     * @param   {SendInvitationsOrCancellationsMode}    sendInvitationsOrCancellationsMode   Indicates if and how invitations and/or cancellations should be sent for items of type Appointment. Required if items contains at least one Appointment instance.
     * @param   {ServiceErrorHandling}                  errorHandling                        What type of error handling should be performed.
     * @param   {boolean}                               suppressReadReceipt                  Whether to suppress read receipts
     * @return  {IPromise<ServiceResponseCollection<UpdateItemResponse>>}                    A ServiceResponseCollection providing update results for each of the specified items :Promise.
     */
    ExchangeService.prototype.InternalUpdateItems = function (items, savedItemsDestinationFolderId, conflictResolution, messageDisposition, sendInvitationsOrCancellationsMode, errorHandling, suppressReadReceipt) {
        var request = new UpdateItemRequest_1.UpdateItemRequest(this, errorHandling);
        //request.Items.AddRange(items);
        ExtensionMethods_1.ArrayHelper.AddRange(request.Items, items);
        request.SavedItemsDestinationFolder = savedItemsDestinationFolderId;
        request.MessageDisposition = messageDisposition;
        request.ConflictResolutionMode = conflictResolution;
        request.SendInvitationsOrCancellationsMode = sendInvitationsOrCancellationsMode;
        request.SuppressReadReceipts = suppressReadReceipt;
        return request.Execute();
    };
    /**
     * Loads the properties of multiple items in a single call to EWS. **Unstable for Extended Properties**
     *
     * @param   {Item[]}        items         The items to load the properties of.
     * @param   {PropertySet}   propertySet   The set of properties to load.
     * @return  {IPromise<ServiceResponseCollection<ServiceResponse>>}      A ServiceResponseCollection providing results for each of the specified items :Promise.
     */
    ExchangeService.prototype.LoadPropertiesForItems = function (items, propertySet) {
        EwsUtilities_1.EwsUtilities.ValidateParamCollection(items, "items");
        EwsUtilities_1.EwsUtilities.ValidateParam(propertySet, "propertySet");
        return this.InternalLoadPropertiesForItems(items, propertySet, ServiceErrorHandling_1.ServiceErrorHandling.ReturnErrors);
    };
    /**
     * Mark items as junk.
     *
     * @param   {ItemId[]}      itemIds    ItemIds for the items to mark
     * @param   {boolean}       isJunk     Whether the items are junk.  If true, senders are add to blocked sender list. If false, senders are removed.
     * @param   {boolean}       moveItem   Whether to move the item.  Items are moved to junk folder if isJunk is true, inbox if isJunk is false.
     * @return  {IPromise<ServiceResponseCollection<MarkAsJunkResponse>>}       A ServiceResponseCollection providing itemIds for each of the moved items :Promise.
     */
    ExchangeService.prototype.MarkAsJunk = function (itemIds, isJunk, moveItem) {
        var request = new MarkAsJunkRequest_1.MarkAsJunkRequest(this, ServiceErrorHandling_1.ServiceErrorHandling.ReturnErrors);
        request.ItemIds.AddRange(itemIds);
        request.IsJunk = isJunk;
        request.MoveItem = moveItem;
        return request.Execute();
    };
    /**
     * @internal Move an item.
     *
     * @param   {ItemId}    itemId                The Id of the item to move.
     * @param   {FolderId}  destinationFolderId   The Id of the folder to move the item to.
     * @return  {IPromise<Item>}                  The moved item :Promise.
     */
    ExchangeService.prototype.MoveItem = function (itemId, destinationFolderId) {
        return this.InternalMoveItems([itemId], destinationFolderId, null, ServiceErrorHandling_1.ServiceErrorHandling.ThrowOnError).then(function (responses) {
            return responses.__thisIndexer(0).Item;
        });
    };
    ExchangeService.prototype.MoveItems = function (itemIds, destinationFolderId, returnNewItemIds) {
        if (returnNewItemIds === void 0) { returnNewItemIds = null; }
        EwsUtilities_1.EwsUtilities.ValidateMethodVersion(this, ExchangeVersion_1.ExchangeVersion.Exchange2010_SP1, "MoveItems");
        return this.InternalMoveItems(itemIds, destinationFolderId, returnNewItemIds, ServiceErrorHandling_1.ServiceErrorHandling.ReturnErrors);
    };
    /**
     * @internal Sends an item.
     *
     * @param   {Item}      item                           The item.
     * @param   {FolderId}  savedCopyDestinationFolderId   The saved copy destination folder id.
     */
    ExchangeService.prototype.SendItem = function (item, savedCopyDestinationFolderId) {
        var request = new SendItemRequest_1.SendItemRequest(this, ServiceErrorHandling_1.ServiceErrorHandling.ThrowOnError);
        request.Items = [item];
        request.SavedCopyDestinationFolderId = savedCopyDestinationFolderId;
        return request.Execute();
    };
    ExchangeService.prototype.UpdateItem = function (item, savedItemsDestinationFolderId, conflictResolution, messageDisposition, sendInvitationsOrCancellationsMode, suppressReadReceipts) {
        if (suppressReadReceipts === void 0) { suppressReadReceipts = false; }
        return this.InternalUpdateItems([item], savedItemsDestinationFolderId, conflictResolution, messageDisposition, sendInvitationsOrCancellationsMode, ServiceErrorHandling_1.ServiceErrorHandling.ThrowOnError, suppressReadReceipts).then(function (responses) {
            return responses.__thisIndexer(0).ReturnedItem;
        });
    };
    ExchangeService.prototype.UpdateItems = function (items, savedItemsDestinationFolderId, conflictResolution, messageDisposition, sendInvitationsOrCancellationsMode, suppressReadReceipts) {
        if (suppressReadReceipts === void 0) { suppressReadReceipts = false; }
        // All items have to exist on the server (!new) and modified (dirty)
        if (!items.every(function (item) { return (!item.IsNew && item.IsDirty); })) {
            throw new ServiceValidationException_1.ServiceValidationException(Strings_1.Strings.UpdateItemsDoesNotSupportNewOrUnchangedItems);
        }
        // Make sure that all items do *not* have unprocessed attachments.
        if (!items.every(function (item) { return !item.HasUnprocessedAttachmentChanges(); })) {
            throw new ServiceValidationException_1.ServiceValidationException(Strings_1.Strings.UpdateItemsDoesNotAllowAttachments);
        }
        return this.InternalUpdateItems(items, savedItemsDestinationFolderId, conflictResolution, messageDisposition, sendInvitationsOrCancellationsMode, ServiceErrorHandling_1.ServiceErrorHandling.ReturnErrors, suppressReadReceipts);
    };
    /* #endregion Item operations 47*/
    /* #region Attachment operations */
    /**
     * @internal Creates attachments.
     *
     * @param   {string}            parentItemId   The parent item id.
     * @param   {Attachment[]}      attachments            The attachments.
     * @return  {IPromise<ServiceResponseCollection<CreateAttachmentResponse>>}     Service response collection :Promise.
     */
    ExchangeService.prototype.CreateAttachments = function (parentItemId, attachments) {
        var request = new CreateAttachmentRequest_1.CreateAttachmentRequest(this, ServiceErrorHandling_1.ServiceErrorHandling.ReturnErrors);
        request.ParentItemId = parentItemId;
        ExtensionMethods_1.ArrayHelper.AddRange(request.Attachments, attachments); //request.Attachments.AddRange(attachments);
        return request.Execute();
    };
    /**
     * @internal Deletes attachments.
     *
     * @param   {Attachment[]}   attachments   The attachments.
     * @return  {IPromise<ServiceResponseCollection<DeleteAttachmentResponse>>}     Service response collection :Promise.
     */
    ExchangeService.prototype.DeleteAttachments = function (attachments) {
        var request = new DeleteAttachmentRequest_1.DeleteAttachmentRequest(this, ServiceErrorHandling_1.ServiceErrorHandling.ReturnErrors);
        ExtensionMethods_1.ArrayHelper.AddRange(request.Attachments, attachments); //request.Attachments.AddRange(attachments);
        return request.Execute();
    };
    /**
     * @internal Gets an attachment.
     *
     * @param   {Attachment}                    attachment             The attachment.
     * @param   {BodyType}                      bodyType               Type of the body.
     * @param   {PropertyDefinitionBase[]}      additionalProperties   The additional properties.
     */
    ExchangeService.prototype.GetAttachment = function (attachment, bodyType, additionalProperties) {
        return this.InternalGetAttachments([attachment], bodyType, additionalProperties, ServiceErrorHandling_1.ServiceErrorHandling.ThrowOnError);
    };
    ExchangeService.prototype.GetAttachments = function (attachmentsOrIds, bodyType, additionalProperties) {
        var ids = ExtensionMethods_1.ArrayHelper.OfType(attachmentsOrIds, function (attachment) { return typeof attachment === 'string'; });
        if (ids && ids.length > 0) {
            var request = new GetAttachmentRequest_1.GetAttachmentRequest(this, ServiceErrorHandling_1.ServiceErrorHandling.ReturnErrors);
            ExtensionMethods_1.ArrayHelper.AddRange(request.AttachmentIds, attachmentsOrIds);
            request.BodyType = bodyType;
            if (additionalProperties != null) {
                ExtensionMethods_1.ArrayHelper.AddRange(request.AdditionalProperties, additionalProperties);
            }
            return request.Execute();
        }
        else {
            return this.InternalGetAttachments(attachmentsOrIds, bodyType, additionalProperties, ServiceErrorHandling_1.ServiceErrorHandling.ReturnErrors);
        }
    };
    /**
     * Gets attachments.
     *
     * @param   {string[]}                      attachmentIds          The attachment ids.
     * @param   {BodyType}                      bodyType               Type of the body.
     * @param   {PropertyDefinitionBase[]}      additionalProperties   The additional properties.
     * @return  {IPromise<ServiceResponseCollection<GetAttachmentResponse>>}        Service response collection :Promise.
     */
    ExchangeService.prototype.InternalGetAttachments = function (attachments, bodyType, additionalProperties, errorHandling) {
        var request = new GetAttachmentRequest_1.GetAttachmentRequest(this, errorHandling);
        ExtensionMethods_1.ArrayHelper.AddRange(request.Attachments, attachments);
        request.BodyType = bodyType;
        if (additionalProperties != null) {
            ExtensionMethods_1.ArrayHelper.AddRange(request.AdditionalProperties, additionalProperties);
        }
        return request.Execute();
    };
    ExchangeService.prototype.ExpandGroup = function (emailAddressOrsmtpAddressOrGroupId, routingType) {
        // EwsUtilities.ValidateParam(emailAddressOrsmtpAddressOrGroupId, "address");
        // EwsUtilities.ValidateParam(routingType, "routingType");
        //EwsUtilities.ValidateParam(emailAddress, "emailAddress");
        var emailAddress = new EmailAddress_1.EmailAddress();
        if (emailAddressOrsmtpAddressOrGroupId instanceof EmailAddress_1.EmailAddress) {
            emailAddress = emailAddressOrsmtpAddressOrGroupId;
        }
        else if (emailAddressOrsmtpAddressOrGroupId instanceof ItemId_1.ItemId) {
            emailAddress.Id = emailAddressOrsmtpAddressOrGroupId;
        }
        else if (typeof emailAddressOrsmtpAddressOrGroupId === 'string') {
            emailAddress = new EmailAddress_1.EmailAddress(emailAddressOrsmtpAddressOrGroupId);
        }
        if (routingType) {
            emailAddress.RoutingType = routingType;
        }
        var request = new ExpandGroupRequest_1.ExpandGroupRequest(this);
        request.EmailAddress = emailAddress;
        return request.Execute().then(function (response) {
            return response.__thisIndexer(0).Members;
        });
    };
    /**
     * Get the password expiration date
     *
     * @param   {string}   mailboxSmtpAddress   The e-mail address of the user.
     * @return  {IPromise<DateTime>}            The password expiration date :Promise.
     */
    ExchangeService.prototype.GetPasswordExpirationDate = function (mailboxSmtpAddress) {
        var request = new GetPasswordExpirationDateRequest_1.GetPasswordExpirationDateRequest(this);
        request.MailboxSmtpAddress = mailboxSmtpAddress;
        return request.Execute().then(function (response) {
            return response.PasswordExpirationDate;
        });
    };
    ExchangeService.prototype.ResolveName = function (nameToResolve, parentFolderIdsOrSearchScope, searchScopeOrReturnContactDetails, returnContactDetailsOrContactDataPropertySet, contactDataPropertySet) {
        if (contactDataPropertySet === void 0) { contactDataPropertySet = null; }
        var argsLength = arguments.length;
        if (argsLength < 1 && argsLength > 5) {
            throw new Error("ExchangeService.ts - ResolveName - invalid number of arguments, check documentation and try again.");
        }
        //position 1 - nameToResolve - no change, same for all overload
        var searchScope = null;
        var parentFolderIds = null;
        //position 2 - parentFolderIdsOrSearchScope
        if (argsLength >= 2) {
            if (typeof parentFolderIdsOrSearchScope === 'number') {
                searchScope = parentFolderIdsOrSearchScope;
            }
            else if (Array.isArray(parentFolderIdsOrSearchScope)) {
                parentFolderIds = parentFolderIdsOrSearchScope;
            }
        }
        var returnContactDetails = false;
        //position 3 - searchScopeOrReturnContactDetails
        if (argsLength >= 3) {
            if (typeof searchScopeOrReturnContactDetails === 'boolean') {
                if (typeof parentFolderIdsOrSearchScope !== 'number') {
                    throw new Error("ExchangeService.ts - ResolveName with " + argsLength + " parameters - incorrect uses of parameter at 2nd position, it must be ResolveNameSearchLocation when using boolean at 3rd place");
                }
                returnContactDetails = searchScopeOrReturnContactDetails;
            }
            else if (typeof searchScopeOrReturnContactDetails === 'number') {
                if (!Array.isArray(parentFolderIdsOrSearchScope)) {
                    throw new Error("ExchangeService.ts - ResolveName with " + argsLength + " parameters - incorrect uses of parameter at 2nd position, it must be FolderId[] when using ResolveNameSearchLocation at 3rd place");
                }
                searchScope = searchScopeOrReturnContactDetails;
            }
            else {
                throw new Error("ExchangeService.ts - ResolveName with " + argsLength + " parameters - incorrect uses of parameter at 3rd position, must be boolean, or ResolveNameSearchLocation");
            }
        }
        //position 4 - returnContactDetailsOrContactDataPropertySet
        if (argsLength >= 4) {
            if (returnContactDetailsOrContactDataPropertySet instanceof PropertySet_1.PropertySet) {
                if (typeof searchScopeOrReturnContactDetails !== 'boolean') {
                    throw new Error("ExchangeService.ts - ResolveName with " + argsLength + " parameters - incorrect uses of parameter at 3rd position, it must be boolean when using PropertySet at 4th place");
                }
                contactDataPropertySet = returnContactDetailsOrContactDataPropertySet;
            }
            else if (typeof returnContactDetailsOrContactDataPropertySet === 'boolean') {
                if (typeof searchScopeOrReturnContactDetails !== 'number') {
                    throw new Error("ExchangeService.ts - ResolveName with " + argsLength + " parameters - incorrect uses of parameter at 3rd position, it must be ResolveNameSearchLocation when using boolean at 4th place");
                }
                returnContactDetails = returnContactDetailsOrContactDataPropertySet;
            }
            else {
                throw new Error("ExchangeService.ts - ResolveName with " + argsLength + " parameters - incorrect uses of parameter at 4th  position, must be  PropertySet or boolean");
            }
        }
        //position 5 - contactDataPropertySet
        if (argsLength >= 5) {
            if (typeof returnContactDetailsOrContactDataPropertySet !== 'boolean') {
                throw new Error("ExchangeService.ts - ResolveName with " + argsLength + " parameters - incorrect uses of parameter at 4th position, it must be boolean when using PropertySet at 5th place");
            }
        }
        var request = new ResolveNamesRequest_1.ResolveNamesRequest(this);
        request.NameToResolve = nameToResolve;
        request.ReturnFullContactData = returnContactDetails;
        request.ParentFolderIds.AddRange(parentFolderIds);
        request.SearchLocation = searchScope;
        request.ContactDataPropertySet = contactDataPropertySet;
        return request.Execute().then(function (response) {
            return response.__thisIndexer(0).Resolutions;
        });
    };
    /* #endregion AD related operations */
    /* #region Notification operations */
    // BeginGetEvents(callback: Function /*System.AsyncCallback*/, state: any, subscriptionId: string, watermark: string): Function /*System.IAsyncResult*/ { throw new Error("ExchangeService.ts - BeginGetEvents : Not implemented."); }
    // BeginSubscribeToPullNotifications(callback: Function /*System.AsyncCallback*/, state: any, folderIds: any[] /*System.Collections.Generic.IEnumerable<T>*/, timeout: number, watermark: string, eventTypes: any): Function /*System.IAsyncResult*/ { throw new Error("ExchangeService.ts - BeginSubscribeToPullNotifications : Not implemented."); }
    // BeginSubscribeToPullNotificationsOnAllFolders(callback: Function /*System.AsyncCallback*/, state: any, timeout: number, watermark: string, eventTypes: any): Function /*System.IAsyncResult*/ { throw new Error("ExchangeService.ts - BeginSubscribeToPullNotificationsOnAllFolders : Not implemented."); }
    // BeginSubscribeToPushNotifications(callback: Function /*System.AsyncCallback*/, state: any, folderIds: any[] /*System.Collections.Generic.IEnumerable<T>*/, url: Uri, frequency: number, watermark: string, eventTypes: any): Function /*System.IAsyncResult*/ { throw new Error("ExchangeService.ts - BeginSubscribeToPushNotifications : Not implemented."); }
    // //BeginSubscribeToPushNotifications(callback: Function /*System.AsyncCallback*/, state: any, folderIds: any[] /*System.Collections.Generic.IEnumerable<T>*/, url: Uri, frequency: number, watermark: string, callerData: string, eventTypes: any): Function /*System.IAsyncResult*/ { throw new Error("ExchangeService.ts - BeginSubscribeToPushNotifications : Not implemented."); }
    // BeginSubscribeToPushNotificationsOnAllFolders(callback: Function /*System.AsyncCallback*/, state: any, url: Uri, frequency: number, watermark: string, eventTypes: any): Function /*System.IAsyncResult*/ { throw new Error("ExchangeService.ts - BeginSubscribeToPushNotificationsOnAllFolders : Not implemented."); }
    // //BeginSubscribeToPushNotificationsOnAllFolders(callback: Function /*System.AsyncCallback*/, state: any, url: Uri, frequency: number, watermark: string, callerData: string, eventTypes: any): Function /*System.IAsyncResult*/ { throw new Error("ExchangeService.ts - BeginSubscribeToPushNotificationsOnAllFolders : Not implemented."); }
    // BeginSubscribeToStreamingNotifications(callback: Function /*System.AsyncCallback*/, state: any, folderIds: any[] /*System.Collections.Generic.IEnumerable<T>*/, eventTypes: any): Function /*System.IAsyncResult*/ { throw new Error("ExchangeService.ts - BeginSubscribeToStreamingNotifications : Not implemented."); }
    // BeginSubscribeToStreamingNotificationsOnAllFolders(callback: Function /*System.AsyncCallback*/, state: any, eventTypes: any): Function /*System.IAsyncResult*/ { throw new Error("ExchangeService.ts - BeginSubscribeToStreamingNotificationsOnAllFolders : Not implemented."); }
    // BeginUnsubscribe(callback: Function /*System.AsyncCallback*/, state: any, subscriptionId: string): Function /*System.IAsyncResult*/ { throw new Error("ExchangeService.ts - BeginUnsubscribe : Not implemented."); }
    //BuildGetEventsRequest(subscriptionId: string, watermark: string): GetEventsRequest { throw new Error("ExchangeService.ts - BuildGetEventsRequest : Not implemented."); }
    //BuildSubscribeToPullNotificationsRequest(folderIds: any[] /*System.Collections.Generic.IEnumerable<T>*/, timeout: number, watermark: string, eventTypes: any): SubscribeToPullNotificationsRequest { throw new Error("ExchangeService.ts - BuildSubscribeToPullNotificationsRequest : Not implemented."); }
    //BuildSubscribeToPushNotificationsRequest(folderIds: any[] /*System.Collections.Generic.IEnumerable<T>*/, url: Uri, frequency: number, watermark: string, callerData: string, eventTypes: any): SubscribeToPushNotificationsRequest { throw new Error("ExchangeService.ts - BuildSubscribeToPushNotificationsRequest : Not implemented."); }
    //BuildSubscribeToStreamingNotificationsRequest(folderIds: any[] /*System.Collections.Generic.IEnumerable<T>*/, eventTypes: any): SubscribeToStreamingNotificationsRequest { throw new Error("ExchangeService.ts - BuildSubscribeToStreamingNotificationsRequest : Not implemented."); }
    //BuildUnsubscribeRequest(subscriptionId: string): UnsubscribeRequest { throw new Error("ExchangeService.ts - BuildUnsubscribeRequest : Not implemented."); }
    //EndGetEvents(asyncResult: Function /*System.IAsyncResult*/): GetEventsResults { throw new Error("ExchangeService.ts - EndGetEvents : Not implemented."); }
    //EndSubscribeToPullNotifications(asyncResult: Function /*System.IAsyncResult*/): PullSubscription { throw new Error("ExchangeService.ts - EndSubscribeToPullNotifications : Not implemented."); }
    //EndSubscribeToPushNotifications(asyncResult: Function /*System.IAsyncResult*/): PushSubscription { throw new Error("ExchangeService.ts - EndSubscribeToPushNotifications : Not implemented."); }
    //EndSubscribeToStreamingNotifications(asyncResult: Function /*System.IAsyncResult*/): StreamingSubscription { throw new Error("ExchangeService.ts - EndSubscribeToStreamingNotifications : Not implemented."); }
    //EndUnsubscribe(asyncResult: Function /*System.IAsyncResult*/): any { throw new Error("ExchangeService.ts - EndUnsubscribe : Not implemented."); }
    ExchangeService.prototype.GetEvents = function (subscriptionId, watermark) { throw new Error("ExchangeService.ts - GetEvents : Not implemented."); };
    //SetTeamMailbox(emailAddress: EmailAddress, sharePointSiteUrl: Uri, state: TeamMailboxLifecycleState): any { throw new Error("ExchangeService.ts - SetTeamMailbox : Not implemented."); }
    //SubscribeToPullNotifications(folderIds: any[] /*System.Collections.Generic.IEnumerable<T>*/, timeout: number, watermark: string, eventTypes: any): PullSubscription { throw new Error("ExchangeService.ts - SubscribeToPullNotifications : Not implemented."); }
    //SubscribeToPullNotificationsOnAllFolders(timeout: number, watermark: string, eventTypes: any): PullSubscription { throw new Error("ExchangeService.ts - SubscribeToPullNotificationsOnAllFolders : Not implemented."); }
    //SubscribeToPushNotifications(folderIds: any[] /*System.Collections.Generic.IEnumerable<T>*/, url: Uri, frequency: number, watermark: string, callerData: string, eventTypes: any): PushSubscription { throw new Error("ExchangeService.ts - SubscribeToPushNotifications : Not implemented."); }
    ////SubscribeToPushNotifications(folderIds: any[] /*System.Collections.Generic.IEnumerable<T>*/, url: Uri, frequency: number, watermark: string, eventTypes: any): PushSubscription { throw new Error("ExchangeService.ts - SubscribeToPushNotifications : Not implemented."); }
    //SubscribeToPushNotificationsOnAllFolders(url: Uri, frequency: number, watermark: string, callerData: string, eventTypes: any): PushSubscription { throw new Error("ExchangeService.ts - SubscribeToPushNotificationsOnAllFolders : Not implemented."); }
    ////SubscribeToPushNotificationsOnAllFolders(url: Uri, frequency: number, watermark: string, eventTypes: any): PushSubscription { throw new Error("ExchangeService.ts - SubscribeToPushNotificationsOnAllFolders : Not implemented."); }
    //SubscribeToStreamingNotifications(folderIds: any[] /*System.Collections.Generic.IEnumerable<T>*/, eventTypes: any): StreamingSubscription { throw new Error("ExchangeService.ts - SubscribeToStreamingNotifications : Not implemented."); }
    //SubscribeToStreamingNotificationsOnAllFolders(eventTypes: any): StreamingSubscription { throw new Error("ExchangeService.ts - SubscribeToStreamingNotificationsOnAllFolders : Not implemented."); }
    //UnpinTeamMailbox(emailAddress: EmailAddress): any { throw new Error("ExchangeService.ts - UnpinTeamMailbox : Not implemented."); }
    ExchangeService.prototype.Unsubscribe = function (subscriptionId) { throw new Error("ExchangeService.ts - Unsubscribe : Not implemented."); };
    ExchangeService.prototype.GetUserAvailability = function (attendees, timeWindow, requestedData, options) {
        if (options === void 0) { options = new AvailabilityOptions_1.AvailabilityOptions(); }
        EwsUtilities_1.EwsUtilities.ValidateParamCollection(attendees, "attendees");
        EwsUtilities_1.EwsUtilities.ValidateParam(timeWindow, "timeWindow");
        EwsUtilities_1.EwsUtilities.ValidateParam(options, "options");
        var request = new GetUserAvailabilityRequest_1.GetUserAvailabilityRequest(this);
        request.Attendees = attendees;
        request.TimeWindow = timeWindow;
        request.RequestedData = requestedData;
        request.Options = options;
        return request.Execute().then(function (responses) {
            return responses;
        });
    };
    /**
     * Gets Out of Office (OOF) settings for a specific user. Calling this method results in a call to EWS.
     *
     * @param   {string}   smtpAddress   The SMTP address of the user for which to retrieve OOF settings.
     * @return  {IPromise<OofSettings>}     An OofSettings instance containing OOF information for the specified user.
     */
    ExchangeService.prototype.GetUserOofSettings = function (smtpAddress) {
        EwsUtilities_1.EwsUtilities.ValidateParam(smtpAddress, "smtpAddress");
        var request = new GetUserOofSettingsRequest_1.GetUserOofSettingsRequest(this);
        request.SmtpAddress = smtpAddress;
        return request.Execute().then(function (response) {
            return response.OofSettings;
        });
    };
    ExchangeService.prototype.SetUserOofSettings = function (smtpAddress, oofSettings) {
        EwsUtilities_1.EwsUtilities.ValidateParam(smtpAddress, "smtpAddress");
        EwsUtilities_1.EwsUtilities.ValidateParam(oofSettings, "oofSettings");
        var request = new SetUserOofSettingsRequest_1.SetUserOofSettingsRequest(this);
        request.SmtpAddress = smtpAddress;
        request.OofSettings = oofSettings;
        return request.Execute();
    };
    /* #endregion Availability operations */
    /* #region Conversation */
    // ApplyConversationAction<TResponse extends ServiceResponse>(actionType: ConversationActionType, conversationIds: any[] /*System.Collections.Generic.IEnumerable<T>*/, processRightAway: boolean, categories: StringList, enableAlwaysDelete: boolean, destinationFolderId: FolderId, errorHandlingMode: ServiceErrorHandling): ServiceResponseCollection<TResponse> { throw new Error("ExchangeService.ts - ApplyConversationAction<TResponse extends ServiceResponse> : Not implemented."); }
    // ApplyConversationOneTimeAction<TResponse extends ServiceResponse>(actionType: ConversationActionType, idTimePairs: any[] /*System.Collections.Generic.IEnumerable<T>*/, contextFolderId: FolderId, destinationFolderId: FolderId, deleteType: DeleteMode, isRead: boolean, retentionPolicyType: RetentionType, retentionPolicyTagId: any /*System.Guid*/, flag: Flag, suppressReadReceipts: boolean, errorHandlingMode: ServiceErrorHandling): ServiceResponseCollection<TResponse> { throw new Error("ExchangeService.ts - ApplyConversationOneTimeAction<TResponse extends ServiceResponse> : Not implemented."); }
    //DisableAlwaysCategorizeItemsInConversations(conversationId: any[] /*System.Collections.Generic.IEnumerable<T>*/, processSynchronously: boolean): ServiceResponseCollection<TResponse> { throw new Error("ExchangeService.ts - DisableAlwaysCategorizeItemsInConversations : Not implemented."); }
    //DisableAlwaysDeleteItemsInConversations(conversationId: any[] /*System.Collections.Generic.IEnumerable<T>*/, processSynchronously: boolean): ServiceResponseCollection<TResponse> { throw new Error("ExchangeService.ts - DisableAlwaysDeleteItemsInConversations : Not implemented."); }
    //DisableAlwaysMoveItemsInConversations(conversationIds: any[] /*System.Collections.Generic.IEnumerable<T>*/, processSynchronously: boolean): ServiceResponseCollection<TResponse> { throw new Error("ExchangeService.ts - DisableAlwaysMoveItemsInConversations : Not implemented."); }
    //EnableAlwaysCategorizeItemsInConversations(conversationId: any[] /*System.Collections.Generic.IEnumerable<T>*/, categories: System.Collections.Generic.IEnumerable<string>, processSynchronously: boolean): ServiceResponseCollection<TResponse> { throw new Error("ExchangeService.ts - EnableAlwaysCategorizeItemsInConversations : Not implemented."); }
    //EnableAlwaysDeleteItemsInConversations(conversationId: any[] /*System.Collections.Generic.IEnumerable<T>*/, processSynchronously: boolean): ServiceResponseCollection<TResponse> { throw new Error("ExchangeService.ts - EnableAlwaysDeleteItemsInConversations : Not implemented."); }
    //EnableAlwaysMoveItemsInConversations(conversationId: any[] /*System.Collections.Generic.IEnumerable<T>*/, destinationFolderId: FolderId, processSynchronously: boolean): ServiceResponseCollection<TResponse> { throw new Error("ExchangeService.ts - EnableAlwaysMoveItemsInConversations : Not implemented."); }
    ////FindConversation(view: ViewBase, folderId: FolderId): System.Collections.Generic.ICollection<T> { throw new Error("ExchangeService.ts - FindConversation : Not implemented."); }
    ////FindConversation(view: ViewBase, folderId: FolderId, queryString: string, returnHighlightTerms: boolean): FindConversationResults { throw new Error("ExchangeService.ts - FindConversation : Not implemented."); }
    ////FindConversation(view: ViewBase, folderId: FolderId, queryString: string): System.Collections.Generic.ICollection<T> { throw new Error("ExchangeService.ts - FindConversation : Not implemented."); }
    ////FindConversation(view: ViewBase, folderId: FolderId, queryString: string, returnHighlightTerms: boolean, mailboxScope: MailboxSearchLocation): FindConversationResults { throw new Error("ExchangeService.ts - FindConversation : Not implemented."); }
    //GetConversationItems(conversations: any[] /*System.Collections.Generic.IEnumerable<T>*/, propertySet: PropertySet, foldersToIgnore: any[] /*System.Collections.Generic.IEnumerable<T>*/, sortOrder: ConversationSortOrder): ServiceResponseCollection<TResponse> { throw new Error("ExchangeService.ts - GetConversationItems : Not implemented."); }
    ////GetConversationItems(conversationId: ConversationId, propertySet: PropertySet, syncState: string, foldersToIgnore: any[] /*System.Collections.Generic.IEnumerable<T>*/, sortOrder: ConversationSortOrder): ConversationResponse { throw new Error("ExchangeService.ts - GetConversationItems : Not implemented."); }
    ////GetConversationItems(conversations: any[] /*System.Collections.Generic.IEnumerable<T>*/, propertySet: PropertySet, foldersToIgnore: any[] /*System.Collections.Generic.IEnumerable<T>*/, sortOrder: ConversationSortOrder, mailboxScope: MailboxSearchLocation): ServiceResponseCollection<TResponse> { throw new Error("ExchangeService.ts - GetConversationItems : Not implemented."); }
    //InternalGetConversationItems(conversations: any[] /*System.Collections.Generic.IEnumerable<T>*/, propertySet: PropertySet, foldersToIgnore: any[] /*System.Collections.Generic.IEnumerable<T>*/, sortOrder: ConversationSortOrder, mailboxScope: MailboxSearchLocation, maxItemsToReturn: number, errorHandling: ServiceErrorHandling): ServiceResponseCollection<TResponse> { throw new Error("ExchangeService.ts - InternalGetConversationItems : Not implemented."); }
    //CopyItemsInConversations(idLastSyncTimePairs: any[] /*System.Collections.Generic.IEnumerable<T>*/, contextFolderId: FolderId, destinationFolderId: FolderId): ServiceResponseCollection<TResponse> { throw new Error("ExchangeService.ts - CopyItemsInConversations : Not implemented."); }
    //DeleteItemsInConversations(idLastSyncTimePairs: any[] /*System.Collections.Generic.IEnumerable<T>*/, contextFolderId: FolderId, deleteMode: DeleteMode): ServiceResponseCollection<TResponse> { throw new Error("ExchangeService.ts - DeleteItemsInConversations : Not implemented."); }
    //MoveItemsInConversations(idLastSyncTimePairs: any[] /*System.Collections.Generic.IEnumerable<T>*/, contextFolderId: FolderId, destinationFolderId: FolderId): ServiceResponseCollection<TResponse> { throw new Error("ExchangeService.ts - MoveItemsInConversations : Not implemented."); }
    //SetFlagStatusForItemsInConversations(idLastSyncTimePairs: any[] /*System.Collections.Generic.IEnumerable<T>*/, contextFolderId: FolderId, flagStatus: Flag): ServiceResponseCollection<TResponse> { throw new Error("ExchangeService.ts - SetFlagStatusForItemsInConversations : Not implemented."); }
    //SetReadStateForItemsInConversations(idLastSyncTimePairs: any[] /*System.Collections.Generic.IEnumerable<T>*/, contextFolderId: FolderId, isRead: boolean, suppressReadReceipts: boolean): ServiceResponseCollection<TResponse> { throw new Error("ExchangeService.ts - SetReadStateForItemsInConversations : Not implemented."); }
    ////SetReadStateForItemsInConversations(idLastSyncTimePairs: any[] /*System.Collections.Generic.IEnumerable<T>*/, contextFolderId: FolderId, isRead: boolean): ServiceResponseCollection<TResponse> { throw new Error("ExchangeService.ts - SetReadStateForItemsInConversations : Not implemented."); }
    //SetRetentionPolicyForItemsInConversations(idLastSyncTimePairs: any[] /*System.Collections.Generic.IEnumerable<T>*/, contextFolderId: FolderId, retentionPolicyType: RetentionType, retentionPolicyTagId: any /*System.Guid*/): ServiceResponseCollection<TResponse> { throw new Error("ExchangeService.ts - SetRetentionPolicyForItemsInConversations : Not implemented."); }
    /* #end region Conversation */
    /** #region Id conversion operations */
    //ConvertId(id: AlternateIdBase, destinationFormat: IdFormat): AlternateIdBase { throw new Error("ExchangeService.ts - ConvertId : Not implemented."); }
    //ConvertIds(ids: any[] /*System.Collections.Generic.IEnumerable<T>*/, destinationFormat: IdFormat): ServiceResponseCollection<TResponse> { throw new Error("ExchangeService.ts - ConvertIds : Not implemented."); }
    //InternalConvertIds(ids: any[] /*System.Collections.Generic.IEnumerable<T>*/, destinationFormat: IdFormat, errorHandling: ServiceErrorHandling): ServiceResponseCollection<TResponse> { throw new Error("ExchangeService.ts - InternalConvertIds : Not implemented."); }
    /* #endregion Id conversion operations */
    /* #region Delegate management operations */
    // AddDelegates(mailbox: Mailbox, meetingRequestsDeliveryScope: MeetingRequestsDeliveryScope, delegateUsers: any[] /*System.Collections.Generic.IEnumerable<T>*/): DelegateUserResponse[]/*System.Collections.ObjectModel.Collection<DelegateUserResponse>*/ { throw new Error("ExchangeService.ts - AddDelegates : Not implemented."); }
    // //AddDelegates(mailbox: Mailbox, meetingRequestsDeliveryScope: MeetingRequestsDeliveryScope, delegateUsers: any): System.Collections.ObjectModel.Collection<DelegateUserResponse> { throw new Error("ExchangeService.ts - AddDelegates : Not implemented."); }
    //GetDelegates(mailbox: Mailbox, includePermissions: boolean, userIds: any[] /*System.Collections.Generic.IEnumerable<T>*/): DelegateInformation { throw new Error("ExchangeService.ts - GetDelegates : Not implemented."); }
    ////GetDelegates(mailbox: Mailbox, includePermissions: boolean, userIds: any): DelegateInformation { throw new Error("ExchangeService.ts - GetDelegates : Not implemented."); }
    //RemoveDelegates(mailbox: Mailbox, userIds: any[] /*System.Collections.Generic.IEnumerable<T>*/): System.Collections.ObjectModel.Collection<DelegateUserResponse> { throw new Error("ExchangeService.ts - RemoveDelegates : Not implemented."); }
    ////RemoveDelegates(mailbox: Mailbox, userIds: any): System.Collections.ObjectModel.Collection<DelegateUserResponse> { throw new Error("ExchangeService.ts - RemoveDelegates : Not implemented."); }
    //UpdateDelegates(mailbox: Mailbox, meetingRequestsDeliveryScope: MeetingRequestsDeliveryScope, delegateUsers: any): System.Collections.ObjectModel.Collection<DelegateUserResponse> { throw new Error("ExchangeService.ts - UpdateDelegates : Not implemented."); }
    ////UpdateDelegates(mailbox: Mailbox, meetingRequestsDeliveryScope: MeetingRequestsDeliveryScope, delegateUsers: any[] /*System.Collections.Generic.IEnumerable<T>*/): System.Collections.ObjectModel.Collection<DelegateUserResponse> { throw new Error("ExchangeService.ts - UpdateDelegates : Not implemented."); }
    /* #endregion Delegate management operations */
    /* #region UserConfiguration operations */
    //CreateUserConfiguration(userConfiguration: UserConfiguration): any { throw new Error("ExchangeService.ts - CreateUserConfiguration : Not implemented."); }
    //DeleteUserConfiguration(name: string, parentFolderId: FolderId): any { throw new Error("ExchangeService.ts - DeleteUserConfiguration : Not implemented."); }
    //GetUserConfiguration(name: string, parentFolderId: FolderId, properties: UserConfigurationProperties): UserConfiguration { throw new Error("ExchangeService.ts - GetUserConfiguration : Not implemented."); }
    //LoadPropertiesForUserConfiguration(userConfiguration: UserConfiguration, properties: UserConfigurationProperties): any { throw new Error("ExchangeService.ts - LoadPropertiesForUserConfiguration : Not implemented."); }
    //UpdateUserConfiguration(userConfiguration: UserConfiguration): any { throw new Error("ExchangeService.ts - UpdateUserConfiguration : Not implemented."); }
    /* #endregion UserConfiguration operations */
    /* #region InboxRule operations */
    //GetInboxRules(): RuleCollection { throw new Error("ExchangeService.ts - GetInboxRules : Not implemented."); }
    ////GetInboxRules(mailboxSmtpAddress: string): RuleCollection { throw new Error("ExchangeService.ts - GetInboxRules : Not implemented."); }
    //UpdateInboxRules(operations: System.Collections.Generic.IEnumerable<RuleOperation>, removeOutlookRuleBlob: boolean, mailboxSmtpAddress: string): any { throw new Error("ExchangeService.ts - UpdateInboxRules : Not implemented."); }
    ////UpdateInboxRules(operations: System.Collections.Generic.IEnumerable<RuleOperation>, removeOutlookRuleBlob: boolean): any { throw new Error("ExchangeService.ts - UpdateInboxRules : Not implemented."); }
    /* #endregion InboxRule operations */
    /* #region eDiscovery/Compliance operations */
    // BeginGetNonIndexableItemDetails(callback: Function /*System.AsyncCallback*/, state: any, parameters: GetNonIndexableItemDetailsParameters): Function /*System.IAsyncResult*/ { throw new Error("ExchangeService.ts - BeginGetNonIndexableItemDetails : Not implemented."); }
    // BeginGetNonIndexableItemStatistics(callback: Function /*System.AsyncCallback*/, state: any, parameters: GetNonIndexableItemStatisticsParameters): Function /*System.IAsyncResult*/ { throw new Error("ExchangeService.ts - BeginGetNonIndexableItemStatistics : Not implemented."); }
    // BeginSearchMailboxes(callback: Function /*System.AsyncCallback*/, state: any, searchParameters: SearchMailboxesParameters): Function /*System.IAsyncResult*/ { throw new Error("ExchangeService.ts - BeginSearchMailboxes : Not implemented."); }
    //CreateGetNonIndexableItemDetailsRequest(parameters: GetNonIndexableItemDetailsParameters): GetNonIndexableItemDetailsRequest { throw new Error("ExchangeService.ts - CreateGetNonIndexableItemDetailsRequest : Not implemented."); }
    //CreateGetNonIndexableItemStatisticsRequest(parameters: GetNonIndexableItemStatisticsParameters): GetNonIndexableItemStatisticsRequest { throw new Error("ExchangeService.ts - CreateGetNonIndexableItemStatisticsRequest : Not implemented."); }
    //CreateSearchMailboxesRequest(searchParameters: SearchMailboxesParameters): SearchMailboxesRequest { throw new Error("ExchangeService.ts - CreateSearchMailboxesRequest : Not implemented."); }
    //EndGetNonIndexableItemDetails(asyncResult: Function /*System.IAsyncResult*/): GetNonIndexableItemDetailsResponse { throw new Error("ExchangeService.ts - EndGetNonIndexableItemDetails : Not implemented."); }
    //EndGetNonIndexableItemStatistics(asyncResult: Function /*System.IAsyncResult*/): GetNonIndexableItemStatisticsResponse { throw new Error("ExchangeService.ts - EndGetNonIndexableItemStatistics : Not implemented."); }
    //EndSearchMailboxes(asyncResult: Function /*System.IAsyncResult*/): ServiceResponseCollection<TResponse> { throw new Error("ExchangeService.ts - EndSearchMailboxes : Not implemented."); }
    //GetDiscoverySearchConfiguration(searchId: string, expandGroupMembership: boolean, inPlaceHoldConfigurationOnly: boolean): GetDiscoverySearchConfigurationResponse { throw new Error("ExchangeService.ts - GetDiscoverySearchConfiguration : Not implemented."); }
    //GetSearchableMailboxes(searchFilter: string, expandGroupMembership: boolean): GetSearchableMailboxesResponse { throw new Error("ExchangeService.ts - GetSearchableMailboxes : Not implemented."); }
    //SearchMailboxes(mailboxQueries: any[] /*System.Collections.Generic.IEnumerable<T>*/, resultType: SearchResultType): ServiceResponseCollection<TResponse> { throw new Error("ExchangeService.ts - SearchMailboxes : Not implemented."); }
    ////SearchMailboxes(mailboxQueries: any[] /*System.Collections.Generic.IEnumerable<T>*/, resultType: SearchResultType, sortByProperty: string, sortOrder: SortDirection, pageSize: number, pageDirection: SearchPageDirection, pageItemReference: string): ServiceResponseCollection<TResponse> { throw new Error("ExchangeService.ts - SearchMailboxes : Not implemented."); }
    ////SearchMailboxes(searchParameters: SearchMailboxesParameters): ServiceResponseCollection<TResponse> { throw new Error("ExchangeService.ts - SearchMailboxes : Not implemented."); }
    //SetHoldOnMailboxes(holdId: string, actionType: HoldAction, query: string, inPlaceHoldIdentity: string, itemHoldPeriod: string): SetHoldOnMailboxesResponse { throw new Error("ExchangeService.ts - SetHoldOnMailboxes : Not implemented."); }
    ////SetHoldOnMailboxes(parameters: SetHoldOnMailboxesParameters): SetHoldOnMailboxesResponse { throw new Error("ExchangeService.ts - SetHoldOnMailboxes : Not implemented."); }
    ////SetHoldOnMailboxes(holdId: string, actionType: HoldAction, query: string, mailboxes: System.String[]): SetHoldOnMailboxesResponse { throw new Error("ExchangeService.ts - SetHoldOnMailboxes : Not implemented."); }
    ////SetHoldOnMailboxes(holdId: string, actionType: HoldAction, query: string, inPlaceHoldIdentity: string): SetHoldOnMailboxesResponse { throw new Error("ExchangeService.ts - SetHoldOnMailboxes : Not implemented."); }
    //GetHoldOnMailboxes(holdId: string): GetHoldOnMailboxesResponse { throw new Error("ExchangeService.ts - GetHoldOnMailboxes : Not implemented."); }
    //GetNonIndexableItemDetails(mailboxes: System.String[]): GetNonIndexableItemDetailsResponse { throw new Error("ExchangeService.ts - GetNonIndexableItemDetails : Not implemented."); }
    ////GetNonIndexableItemDetails(mailboxes: System.String[], pageSize: number, pageItemReference: string, pageDirection: SearchPageDirection): GetNonIndexableItemDetailsResponse { throw new Error("ExchangeService.ts - GetNonIndexableItemDetails : Not implemented."); }
    ////GetNonIndexableItemDetails(parameters: GetNonIndexableItemDetailsParameters): GetNonIndexableItemDetailsResponse { throw new Error("ExchangeService.ts - GetNonIndexableItemDetails : Not implemented."); }
    //GetNonIndexableItemStatistics(parameters: GetNonIndexableItemStatisticsParameters): GetNonIndexableItemStatisticsResponse { throw new Error("ExchangeService.ts - GetNonIndexableItemStatistics : Not implemented."); }
    ////GetNonIndexableItemStatistics(mailboxes: System.String[]): GetNonIndexableItemStatisticsResponse { throw new Error("ExchangeService.ts - GetNonIndexableItemStatistics : Not implemented."); }
    /* #endregion eDiscovery/Compliance operations */
    /* #region MRM operations */
    //GetUserRetentionPolicyTags(): GetUserRetentionPolicyTagsResponse { throw new Error("ExchangeService.ts - GetUserRetentionPolicyTags : Not implemented."); }
    /* #endregion MRM operations */
    /* #region Autodiscover */
    /**
     * Adjusts the service URI based on the current type of credentials.
     *
     * @param   {Uri}   uri   The URI.
     * @return  {Uri}         Adjusted URL.
     */
    ExchangeService.prototype.AdjustServiceUriFromCredentials = function (uri) {
        return (this.Credentials != null)
            ? this.Credentials.AdjustUrl(uri)
            : uri;
    };
    ExchangeService.prototype.AutodiscoverUrl = function (emailAddress, validateRedirectionUrlCallback) {
        //validateRedirectionUrlCallback = validateRedirectionUrlCallback || this.DefaultAutodiscoverRedirectionUrlValidationCallback;
        var _this = this;
        if (validateRedirectionUrlCallback === void 0) { validateRedirectionUrlCallback = this.DefaultAutodiscoverRedirectionUrlValidationCallback; }
        var exchangeServiceUrl = null;
        if (this.RequestedServerVersion > ExchangeVersion_1.ExchangeVersion.Exchange2007_SP1) {
            return this.GetAutodiscoverUrl(emailAddress, this.RequestedServerVersion, validateRedirectionUrlCallback).then(function (url) {
                exchangeServiceUrl = url;
                _this.Url = _this.AdjustServiceUriFromCredentials(exchangeServiceUrl);
                //return;
            }, function (err) {
                //catch (AutodiscoverLocalException ex)
                _this.TraceMessage(TraceFlags_1.TraceFlags.AutodiscoverResponse, ExtensionMethods_1.StringHelper.Format("Autodiscover service call failed with error '{0}'. Will try legacy service", err));
                //catch (ServiceRemoteException ex)
                // Special case: if the caller's account is locked we want to return this exception, not continue.
                //        if (ex is AccountIsLockedException)
                //{
                //    throw;
                //}
                //this.TraceMessage(
                //    TraceFlags.AutodiscoverResponse,
                //    string.Format("Autodiscover service call failed with error '{0}'. Will try legacy service", ex.Message));
                // Try legacy Autodiscover provider
                var exchangeServiceUrl = _this.GetAutodiscoverUrl(emailAddress, ExchangeVersion_1.ExchangeVersion.Exchange2007_SP1, validateRedirectionUrlCallback).then(function (url) {
                    _this.Url = _this.AdjustServiceUriFromCredentials(url);
                });
            });
        }
    };
    /**
     * Default implementation of AutodiscoverRedirectionUrlValidationCallback. Always returns true indicating that the URL can be used.
     *
     * @param   {string}   redirectionUrl   The redirection URL.
     * @return  {boolean}                    Returns true.
     */
    ExchangeService.prototype.DefaultAutodiscoverRedirectionUrlValidationCallback = function (redirectionUrl) {
        throw new AutodiscoverLocalException_1.AutodiscoverLocalException(ExtensionMethods_1.StringHelper.Format(Strings_1.Strings.AutodiscoverRedirectBlocked, redirectionUrl));
    };
    /**
     * Gets the EWS URL from Autodiscover.
     *
     * @param   {string}                                        emailAddress                     The email address.
     * @param   {ExchangeVersion}                               requestedServerVersion           Exchange version.
     * @param   {AutodiscoverRedirectionUrlValidationCallback}  validateRedirectionUrlCallback   The validate redirection URL callback.
     * @return  {IPromise<Uri>}                                 Ews URL :Promise.
     */
    ExchangeService.prototype.GetAutodiscoverUrl = function (emailAddress, requestedServerVersion, validateRedirectionUrlCallback) {
        var _this = this;
        var autodiscoverService = new AutodiscoverService_1.AutodiscoverService(null, null, requestedServerVersion);
        autodiscoverService.Credentials = this.Credentials;
        autodiscoverService.RedirectionUrlValidationCallback = validateRedirectionUrlCallback,
            autodiscoverService.EnableScpLookup = this.EnableScpLookup;
        return autodiscoverService.GetUserSettings(emailAddress, UserSettingName_1.UserSettingName.InternalEwsUrl, UserSettingName_1.UserSettingName.ExternalEwsUrl).then(function (response) {
            switch (response.ErrorCode) {
                case AutodiscoverErrorCode_1.AutodiscoverErrorCode.NoError:
                    return _this.GetEwsUrlFromResponse(response, autodiscoverService.IsExternal);
                case AutodiscoverErrorCode_1.AutodiscoverErrorCode.InvalidUser:
                    throw new ServiceRemoteException_1.ServiceRemoteException(ExtensionMethods_1.StringHelper.Format(Strings_1.Strings.InvalidUser, emailAddress));
                case AutodiscoverErrorCode_1.AutodiscoverErrorCode.InvalidRequest:
                    throw new ServiceRemoteException_1.ServiceRemoteException(ExtensionMethods_1.StringHelper.Format(Strings_1.Strings.InvalidAutodiscoverRequest, response.ErrorMessage));
                default:
                    _this.TraceMessage(TraceFlags_1.TraceFlags.AutodiscoverConfiguration, ExtensionMethods_1.StringHelper.Format("No EWS Url returned for user {0}, error code is {1}", emailAddress, response.ErrorCode));
                    throw new ServiceRemoteException_1.ServiceRemoteException(response.ErrorMessage);
            }
        }, function (err) {
            throw err;
        });
    };
    /**
     * Gets the EWS URL from Autodiscover GetUserSettings response.
     *
     * @param   {GetUserSettingsResponse}   response     The response.
     * @param   {boolean}                   isExternal   If true, Autodiscover call was made externally.
     * @return  {Uri}                       EWS URL.
     */
    ExchangeService.prototype.GetEwsUrlFromResponse = function (response, isExternal) {
        var uriString = response.GetSettingValue(UserSettingName_1.UserSettingName.ExternalEwsUrl);
        // Figure out which URL to use: Internal or External.
        // AutoDiscover may not return an external protocol. First try external, then internal.
        // Either protocol may be returned without a configured URL.
        if ((isExternal &&
            uriString) &&
            !ExtensionMethods_1.StringHelper.IsNullOrEmpty(uriString)) {
            return new Uri_1.Uri(uriString);
        }
        else {
            uriString = response.GetSettingValue(UserSettingName_1.UserSettingName.InternalEwsUrl) || uriString;
            if (!ExtensionMethods_1.StringHelper.IsNullOrEmpty(uriString)) {
                return new Uri_1.Uri(uriString);
            }
        }
        // If Autodiscover doesn't return an internal or external EWS URL, throw an exception.
        throw new AutodiscoverLocalException_1.AutodiscoverLocalException(Strings_1.Strings.AutodiscoverDidNotReturnEwsUrl);
    };
    /* #endregion Autodiscover */
    /* #region ClientAccessTokens */
    //GetClientAccessToken(tokenRequests: ClientAccessTokenRequest[]): ServiceResponseCollection<TResponse> { throw new Error("ExchangeService.ts - GetClientAccessToken : Not implemented."); }
    ////GetClientAccessToken(idAndTypes: any[] /*System.Collections.Generic.IEnumerable<T>*/): ServiceResponseCollection<TResponse> { throw new Error("ExchangeService.ts - GetClientAccessToken : Not implemented."); }
    /* #end region ClientAccessTokens */
    /* #region Client Extensibility */
    //GetAppManifests(apiVersionSupported: string, schemaVersionSupported: string): System.Collections.ObjectModel.Collection<ClientApp> { throw new Error("ExchangeService.ts - GetAppManifests : Not implemented."); }
    ////GetAppManifests(): System.Collections.ObjectModel.Collection<System.Xml.XmlDocument> { throw new Error("ExchangeService.ts - GetAppManifests : Not implemented."); }
    //GetAppMarketplaceUrl(apiVersionSupported: string, schemaVersionSupported: string): string { throw new Error("ExchangeService.ts - GetAppMarketplaceUrl : Not implemented."); }
    ////GetAppMarketplaceUrl(): string { throw new Error("ExchangeService.ts - GetAppMarketplaceUrl : Not implemented."); }
    //DisableApp(id: string, disableReason: DisableReasonType): any { throw new Error("ExchangeService.ts - DisableApp : Not implemented."); }
    //InstallApp(manifestStream: any /*System.IO.Stream*/): any { throw new Error("ExchangeService.ts - InstallApp : Not implemented."); }
    //UninstallApp(id: string): any { throw new Error("ExchangeService.ts - UninstallApp : Not implemented."); }
    //GetClientExtension(requestedExtensionIds: StringList, shouldReturnEnabledOnly: boolean, isUserScope: boolean, userId: string, userEnabledExtensionIds: StringList, userDisabledExtensionIds: StringList, isDebug: boolean): GetClientExtensionResponse { throw new Error("ExchangeService.ts - GetClientExtension : Not implemented."); }
    //SetClientExtension(actions: Function[] /*System.Collections.Generic.List<T>*/): any { throw new Error("ExchangeService.ts - SetClientExtension : Not implemented."); }
    //GetEncryptionConfiguration(): GetEncryptionConfigurationResponse { throw new Error("ExchangeService.ts - GetEncryptionConfiguration : Not implemented."); }
    //SetEncryptionConfiguration(imageBase64: string, emailText: string, portalText: string, disclaimerText: string): any { throw new Error("ExchangeService.ts - SetEncryptionConfiguration : Not implemented."); }
    /* #endregion Client Extensibility */
    /* #region Diagnostic Method -- Only used by test */
    //ExecuteDiagnosticMethod(verb: string, parameter: System.Xml.XmlNode): System.Xml.XmlDocument { throw new Error("ExchangeService.ts - ExecuteDiagnosticMethod : Not implemented."); }    
    /* #endregion Diagnostic Method -- Only used by test */
    /* #region Validation */
    ExchangeService.IsMajorMinor = function (versionPart) {
        var MajorMinorSeparator = '.'; //char
        var parts = versionPart.split(MajorMinorSeparator);
        if (parts.length != 2) {
            return false;
        }
        for (var _i = 0, parts_1 = parts; _i < parts_1.length; _i++) {
            var s = parts_1[_i];
            for (var _a = 0, _b = s.split(''); _a < _b.length; _a++) {
                var c = _b[_a];
                if (isNaN(c)) {
                    return false;
                }
            }
        }
        return true;
    };
    /**
     * @internal Validates this instance.
     *
     */
    ExchangeService.prototype.Validate = function () {
        _super.prototype.Validate.call(this);
        if (this.Url == null) {
            throw new ServiceLocalException_1.ServiceLocalException(Strings_1.Strings.ServiceUrlMustBeSet);
        }
        if (this.PrivilegedUserId != null && this.ImpersonatedUserId != null) {
            throw new ServiceLocalException_1.ServiceLocalException(Strings_1.Strings.CannotSetBothImpersonatedAndPrivilegedUser);
        }
        // only one of PrivilegedUserId|ImpersonatedUserId|ManagementRoles can be set.
    };
    /**
     * @internal Validates a new-style version string. This validation is not as strict as server-side validation.
     *
     * @param   {string}   version   the version string
     */
    ExchangeService.ValidateTargetVersion = function (version) {
        var ParameterSeparator = ';'; //char
        var LegacyVersionPrefix = "Exchange20";
        var ParameterValueSeparator = '='; //char
        var ParameterName = "minimum";
        if (ExtensionMethods_1.StringHelper.IsNullOrEmpty(version)) {
            throw new Error("Target version must not be empty."); //ArgumentException
        }
        var parts = version.trim().split(ParameterSeparator);
        if (parts.length > 2) {
            throw new Error("Target version should have the form."); //ArgumentException            
        }
        var skipPart1 = true;
        if (parts.length === 2) {
            // Validate the optional minimum version parameter, "minimum=X.Y"
            var part2 = parts[1].trim();
            var minParts = part2.split(ParameterValueSeparator);
            if (minParts.length == 2 &&
                minParts[0].trim().toUpperCase() === ParameterName.toUpperCase() &&
                ExchangeService.IsMajorMinor(minParts[1].trim())) {
                skipPart1 = false;
            }
            else {
                throw new Error("Target version must match X.Y or Exchange20XX."); //ArgumentException
            }
        }
        if (parts.length >= 0 && !skipPart1) {
            // Validate the header value. We allow X.Y or Exchange20XX.
            var part1 = parts[0].trim();
            if (parts[0].indexOf(LegacyVersionPrefix) === 0) {
            }
            else if (ExchangeService.IsMajorMinor(part1)) {
            }
            else {
                throw new Error("Target version must match X.Y or Exchange20XX."); //ArgumentException
            }
        }
    };
    /* #endregion Validation */
    /* #region Utilities */
    /**
     * @internal Creates an IXHROptions instance and initializes it with the appropriate parameters, based on the configuration of this service object.
     *
     * @param   {string}   methodName   Name of the method.
     * @return  {IXHROptions}           An instance of IXHROptions to call web service with.
     */
    ExchangeService.prototype.PrepareHttpWebRequest = function (methodName) {
        var endpoint = this.Url;
        //this.RegisterCustomBasicAuthModule();
        if (this.RenderingMethod === RenderingMode_1.RenderingMode.JSON) {
        }
        else {
            endpoint = this.AdjustServiceUriFromCredentials(endpoint);
        }
        var request = this.PrepareHttpWebRequestForUrl(endpoint, this.AcceptGzipEncoding, true);
        if (!ExtensionMethods_1.StringHelper.IsNullOrEmpty(this.TargetServerVersion)) {
            request.headers[ExchangeService.TargetServerVersionHeaderName] = this.TargetServerVersion;
        }
        return request;
    };
    /**
     * @internal Processes an HTTP error response.
     *
     * @param   {XMLHttpRequest}   httpWebResponse      The HTTP web response.
     * @param   {SoapFaultDetails}   soapFault          The SoapFault Instance.
     */
    ExchangeService.prototype.ProcessHttpErrorResponse = function (httpWebResponse, soapFault) {
        this.InternalProcessHttpErrorResponse(httpWebResponse, soapFault, TraceFlags_1.TraceFlags.EwsResponseHttpHeaders, TraceFlags_1.TraceFlags.EwsResponse);
    };
    /**
     * Sets the type of the content.
     *
     * @param   {IXHROptions}   request   The request.
     */
    ExchangeService.prototype.SetContentType = function (request /*IEwsHttpWebRequest*/) {
        if (this.renderingMode == RenderingMode_1.RenderingMode.Xml) {
            request.headers["Content-Type"] = "text/xml; charset=utf-8";
            request.headers["Accept"] = "text/xml";
        }
        else if (this.renderingMode == RenderingMode_1.RenderingMode.JSON) {
            request.headers["Content-Type"] = "application/json; charset=utf-8";
            request.headers["Accept"] = "application/json";
        }
        else {
            _super.prototype.SetContentType.call(this, request);
        }
    };
    /* #region Constants */
    ExchangeService.TargetServerVersionHeaderName = "X-EWS-TargetVersion";
    return ExchangeService;
}(ExchangeServiceBase_1.ExchangeServiceBase));
exports.ExchangeService = ExchangeService;
//module ExchangeService { -> moved to its own file to remove circular dependency.
//    export enum RenderingMode {
//        Xml = 0,
//        JSON = 1
//    }
//}
